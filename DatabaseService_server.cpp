// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "DatabaseService.h"
#include "Database.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thread>
#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

class DatabaseServiceHandler : virtual public DatabaseServiceIf {
public:
    shared_ptr<Database> database;

    DatabaseServiceHandler() : database(Database::getInstance()) {

    }

    bool hasData(const std::string& key) {
        return database->hasData(key);
    }

    void getData(GetResult& _return, const std::string& key) {  
        _return = database->getData(key);
        std::cout << "Send value: " << _return.value << std::endl;
    }

    bool setData(const std::string& key, const std::string& value) {
        return database->setData(key, value);
    }

    bool removeData(const std::string& key) {
        return database->removeData(key);
    }
};

int main(int argc, char **argv) {
    int port = 9091;
    shared_ptr<DatabaseServiceHandler> handler(new DatabaseServiceHandler());
    shared_ptr<TProcessor> processor(new DatabaseServiceProcessor(handler));
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    shared_ptr<ThreadManager> threadManager =
            ThreadManager::newSimpleThreadManager((size_t) 8);
    shared_ptr<PlatformThreadFactory> threadFactory(
            new PlatformThreadFactory());
    threadManager->threadFactory(threadFactory);
    threadManager->start();
    TNonblockingServer server(processor, protocolFactory, port, threadManager);
    server.serve();
    return 0;
}
